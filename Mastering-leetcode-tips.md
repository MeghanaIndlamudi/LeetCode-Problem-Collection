# LeetCode Preparation Guide (2025)

This repository provides a structured approach to prepare for coding interviews, specifically for big tech companies like Amazon, Google, and Microsoft. Based on insights from solving over 1,500 LeetCode problems, this guide will help you navigate the overwhelming world of LeetCode and build a strong problem-solving foundation.

## Table of Contents

- [Why LeetCode?](#why-leetcode)
- [Programming Language Selection](#programming-language-selection)
- [Key Fundamentals](#key-fundamentals)
- [Structured Approach to Learning](#structured-approach-to-learning)
- [Pattern Recognition](#pattern-recognition)
- [How to Solve a Problem](#how-to-solve-a-problem)
  - [Step-by-Step Approach](#step-by-step-approach)
- [What to Do When You Get Stuck](#what-to-do-when-you-get-stuck)
- [Practice Tips](#practice-tips)
- [Retaining Knowledge](#retaining-knowledge)
- [Final Thoughts](#final-thoughts)

---

## Why LeetCode?

LeetCode-style problems are a core part of coding interviews at large tech companies like **Amazon**, **Google**, **Microsoft**, etc. These problems test your understanding of algorithms, data structures, and problem-solving skills.

For smaller companies or startups, you might not face LeetCode problems, but for big tech companies, they are essential. Solving these problems will prepare you for high-level interviews.

---

## Programming Language Selection

**Which language should I choose?**

- **Pick a language you're comfortable with.**  
  Language doesn't matter much for LeetCode. The important part is your understanding of algorithms and problem-solving techniques. 

**Key Concepts You Should Know:**
- Variables, loops, functions, and classes.
- Common data structures (arrays, strings, linked lists, etc.)
- Built-in libraries for common data structures and algorithms.

---

## Key Fundamentals

Before diving into solving problems, make sure you're familiar with the following key topics:

1. **Big O Notation & Time Complexity**:  
   Understand how to evaluate the efficiency of your code and optimize it.

2. **Data Structures**:
   - Arrays, Linked Lists, Stacks, Queues
   - Hash Tables, HashMaps
   - Binary Trees, Heaps, Graphs

3. **Fundamental Algorithms**:
   - Sorting (Merge Sort, Quick Sort, etc.)
   - Binary Search
   - Recursion (important for tree and graph problems)

4. **Recursion & Dynamic Programming**:  
   Specially important for tree, graph, and optimization problems.

---

## Structured Approach to Learning

**How should I learn?**

1. **Learn One Topic at a Time**  
   Don't try to tackle everything at once. Start with simple topics and work your way up to more complex ones.

2. **Solve Problems**  
   Once you understand a topic, solve 4-5 easy problems related to that topic to reinforce your learning.

3. **Curated Lists to Follow**  
   - **Top 100 Liked Problems**
   - **Top 150 Interview Problems**
   These lists are the best to guide you through the most important problems asked in interviews.

---

## Pattern Recognition

Focus on recognizing patterns across problems. For example:

- **Sliding Window**: Helps with subarray and substring problems.
- **Two Pointers**: Often used for problems involving sorted arrays or linked lists.
- **Dynamic Programming**: For optimization problems.
- **Backtracking**: For problems like permutations and combinations.
  
Recognizing these patterns helps you solve problems faster and more efficiently.

---

## How to Solve a Problem

### Step-by-Step Approach

1. **Read the Problem Statement Twice**  
   - First time: Get the big picture. What is the problem asking?
   - Second time: Pay attention to constraints, edge cases, and subtle details.

2. **Analyze Input/Output Examples**  
   - Walk through provided examples step by step.
   - Identify patterns that can help form your solution.

3. **Visualize with Pen and Paper**  
   - Draw trees, graphs, or arrays when needed (especially for recursive problems).

4. **Start with a Brute Force Solution**  
   - Solve it the simplest way first, even if inefficient.

5. **Optimize**  
   - Once you have a working solution, focus on optimization:  
     - Leverage information from constraints.
     - Use efficient data structures (e.g., hash tables, binary search).

6. **Analyze Time and Space Complexity**  
   - Evaluate how your solution scales with input size.

7. **Simplify**  
   - Look for ways to make your solution simpler and more efficient.

---

## What to Do When You Get Stuck

1. **Give It Time**  
   - Spend **30-60 minutes** on a problem before moving on. This is your "deep thinking" time.

2. **Look for Hints or Solutions**  
   - If you’re stuck, check LeetCode's **official solution** or top discussions.
   - Try to **understand** the solution, don’t just copy it.

3. **Rewriting the Solution**  
   - After understanding, rewrite the solution from scratch to ensure you've grasped it.

4. **Mark for Revision**  
   - If you still can’t solve it, **mark it for future review**.
   - Revisit it after a few days or weeks.

5. **Engage in Discussions**  
   - Ask questions in the discussion forum or learn from others’ approaches.

---

## Practice Tips

- **Quality Over Quantity**:  
  Focus on solving **300 well-chosen problems** that cover different topics and patterns. Don't rush to solve hundreds of problems just for the sake of it.

- **Timed Practice**:  
  Start timing yourself after solving around 100 problems. Simulate real interview conditions by solving problems within set time limits (e.g., 15 minutes for easy, 30 minutes for medium, 60 minutes for hard).

- **LeetCode Contests**:  
  Participate in LeetCode contests to simulate competitive coding environments.

---

## Retaining Knowledge

- **Review Regularly**:  
  Revisit old problems, especially the challenging ones, to reinforce your understanding.

- **Track Your Progress**:  
  Mark problems you found difficult and return to them after a few weeks.

---

## Final Thoughts

- **Patience**: Mastery takes time. Don’t rush.
- **Consistency is Key**: Practice consistently, even if you feel frustrated.
- **Understand, Don’t Memorize**: Focus on the **underlying concepts** and **patterns**, not just memorizing solutions.
  
By following this approach, you'll gradually improve your problem-solving skills and be well-prepared for coding interviews at top tech companies.

